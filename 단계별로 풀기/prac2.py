# 순서대로 해보자
#
# 1번째 반복
# L = [5,4,1,3,2]일 때,
# L의 길이는 1이 아니므로,  merge_sort(L) = L이 아니다.
# mid = 3이고,
# left = merge_sort([5,4,1])
# right = merge_sort([2,3])
#
# -> 1번째 반복과 while문을 보았을 때, left와 right의 정확한 값을 알아야만 while문을 진행할 수가 있다.
# 그러므로 2번째 반복은 left와 right의 값을 구하기 위함이다.
# --------------------------------------------------------------------------------------
# 2번째 반복
# left = merge_sort([5,4,1])
# right = merge_sort([2,3]) 이므로,
# merge_sort([5,4,1])과 merge_sort([2,3])을 구하면 된다.
#
# 우선 merge_sort([5,4,1])은
# 길이가 1이 아니므로, merge_sort([5,4,1]) = [5,4,1]이 아니다.
# mid = 2이고,
# left = merge_sort([5,4])
# right = [1]이다.
#
# -> 2번째 반복에서도 merge_sort([5,4,1])의 left값을 정확히 알 수 없어 merge_sort([5,4,1])를 구할 수 없다.
# 그러므로 3번째 반복은 merge_sort([5,4])을 구하기 위함이다.
# --------------------------------------------------------------------------------------
# 3번째 반복
# left = merge_sort([5,4])
# right = 1 이므로,
# merge_sort([5,4])를 구하면 된다.
# 우선 merge_sort([5,4])는
# 길이가 1이 아니므로, merge([5,4]) = [5,4]가 아니다.
# mid = 1이고,
# left = [5]
# right = [4]이다.
#
# -> 3번째 반복에서 merge([5,4])의 left와 right값을 모두 알 수 있어 아래 while문을 실행할 수 있다.
#
# i, j =0, 0을 통해 두 그룹, left와 right의 요소값들을 순차적으로 하나씩 넣기 위해 변수선언했다.
# L2는 비어 있는 리스트로 merge_sort([5,4])의 return값을 구하기 위해 변수 선언했다.
#
# 3-1번째 while문
# -> left와 right의 길이(1)가 i, j(0, 0)보다 크므로, 첫 번째 while문을 반복한다.
# left의 첫 번째 값이 right보다 크기 때문에 else를 실행한다.
# L2 = [4]
# ans = [4]
# j = 1이 됐다.
#
# -> left의 길이가 i(0)보다 크지만, right의 길이가 j(1)의 값보다 크지 않으므로, 1번째 while문은 종료된다.
#
# 3-2번째 while문
# -> left의 길이가 0보다 크기 때문에 2번째 while문을 실행한다.
# L2 = [5]
# ans = [5]
# i = 1이 됐다.
#
# -> right의 길이가 j(1)의 값보다 크지 않으므로, 3번째 while문은 실행하지 않고, L2(=[4,5])를 return해
# merge_sort([5,4])의 값은 [4,5]이다.
# -> merge_sort([5,4])의 값을 알게 됐으니 merge_sort([5,4,1])를 구할 수 있게 된다.
# ->  그러므로 4번째 반복은 merge_sort([5,4])의 값을 알게 됐으니 merge_sort([5,4,1])를 구하기 위함이다.
# --------------------------------------------------------------------------------------
# 4번째 반복
# left = merge_sort([5,4]) = [4,5]
# right = [1] 이다.
# -> left, right 모두 정확한 값을 알고 있으므로, while문을 실행할 수 있다.
# i, j = 0, 0
# L2 = [ ] 로 다시 변수 선언된다.
#
# -> left와 right의 길이(2, 1)가 i, j(0, 0)보다 크므로, 첫 번째 while문을 반복한다.
# left의 첫 번째 값이 right의 첫 번째 값보다 크기 때문에 else를 실행한다.
# L2 = [1]
# ans = [1]
# j = 1이 됐다.
#
# -> left의 길이(2)가 i(0)보다 크지만, right의 길이가 j(1)의 값보다 크지 않으므로, 1번째 while문은 종료된다.
# -> left의 길이(2)가 i(0)보다 크기 때문에 2번째 while문을 실행한다.
#
# 3-2번째 while문
# L2 = [1,4]
# ans = [1,4]
# i = 1이 됐다.
#
# -> 여전히, left의 길이(2)가 i(1)보다 크기 때문에 2번째 while문을 한 번 더 실행한다.
# 3-2번째 while문 2번째 반복
# L2 = [1,4,5]
# ans = [1,4,5]
# i = 2가 됐다.
#
# -> left의 길이가 i(2)의 값보다 크지 않으므로, 2번째 while문을 종료하고,
# right의 길이(1)가 j(1)보다 크지않으므로, 3번째 while문을 실행하지 않고, L2(=[1,4,5])를 return해
# merge_sort([5,4,1])의 값은 [1,4,5]이다.
# -> merge_sort([5,4,1])의 값을 알게 됐으니 merge_sort(L)의 left값, [1,4,5]을 구하게 됐다.
# ->  그러므로 5번째 반복은 merge_sort([5,4,1])의 값을 알게 됐으니 merge_sort(L)의 right값인 merge_sort([3,2])를 구하기 위함이다.
# --------------------------------------------------------------------------------------
# 5번째 반복
# left =[3]
# right = [2] 이다.
# -> left, right 모두 정확한 값을 알고 있으므로, while문을 실행할 수 있다.
# i, j = 0, 0
# L2 = [ ] 로 다시 변수 선언된다.
#
# -> left와 right의 길이(1, 1)가 i, j(0, 0)보다 크므로, 첫 번째 while문을 반복한다.
# left의 첫 번째 값이 right의 첫 번째 값보다 크기 때문에 else를 실행한다.
# 5-1번째 while문
# L2 = [2]
# ans = [2]
# j = 1이 됐다.
#
# -> left의 길이(1)가 i(0)보다 크지만, right의 길이(1)가 j(1)의 값보다 크지 않으므로, 1번째 while문은 종료된다.
# -> left의 길이(1)가 i(0)보다 크기 때문에 2번째 while문을 실행한다.
#
# 5-2번째 while문
# L2 = [2,3]
# ans = [2,3]
# i = 1이 됐다.
#
# -> left의 길이(1)가 i(1)의 값보다 크지 않으므로, 2번째 while문을 종료하고,
# right의 길이(1)가 j(1)보다 크지않으므로, 3번째 while문을 실행하지 않고, L2(=[2,3])를 return해
# merge_sort([3,2])의 값은 [2,3]이다.
# -> merge_sort([3,2]) = merge(L)의 right값, [2,3]을 알게 됐으니 merge_sort(L)의 값을 6번째 반복은 merge_sort(L)를 구하기 위함이다.
# --------------------------------------------------------------------------------------
# 6번째 반복
# left = merge_sort([5,4,1]) = [1,4,5]
# right = merge_sort([3,2]) = [3,2] 이다.
# -> left, right 모두 정확한 값을 알고 있으므로, while문을 실행할 수 있다.
# i, j = 0, 0
# L2 = [ ] 로 다시 변수 선언된다.
#
# -> left와 right의 길이(3, 2)가 i, j(0, 0)보다 크므로, 첫 번째 while문을 반복한다.
# 6-1번째 while문
# L2 = [1]
# ans = [1]
# i = 1이 됐다.
#
# -> 여전히 left와 right의 길이(3, 2)가 i, j(1, 0)보다 크므로, 첫 번째 while문을 반복한다.
# 6-1번째 while문
# L2 = [1,2]
# ans = [1,2]
# j = 1이 됐다.
#
# -> 여전히 left와 right의 길이(3, 2)가 i, j(1, 1)보다 크므로, 첫 번째 while문을 반복한다.
# 6-1번째 while문
# L2 = [1,2,3]
# ans = [1,2,3]
# j = 2가 됐다.
#
# -> left의 길이(3)가 i(1)보다 크지만, right의 길이(2)가 j(2)의 값보다 크지 않으므로, 1번째 while문은 종료된다.
# -> left의 길이(3)가 i(1)보다 크기 때문에 2번째 while문을 실행한다.
# 6-2번째 while문
# L2 = [1,2,3,4]
# ans = [1,2,3,4]
# i = 3이 됐다.
#
# -> 여전히, left의 길이(3)가 i(2)보다 크기 때문에 2번째 while문을 실행한다.
# 6-2번째 while문
# L2 = [1,2,3,4,5]
# ans = [1,2,3,4,5]
# i = 3이 됐다.
#
# -> left의 길이(3)가 i(3)의 값보다 크지 않으므로, 2번째 while문을 종료하고,
# right의 길이(2)가 j(2)보다 크지않으므로, 3번째 while문을 실행하지 않고, L2(=[1,2,3,4,5])를 return해
# merge_sort([L])의 값은 [1,2,3,4,5]이다.
#
#
